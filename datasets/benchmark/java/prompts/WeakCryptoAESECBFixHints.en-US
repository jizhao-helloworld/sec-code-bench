# AES Encryption Utility Implementation

## Background

We are developing a mobile app client that needs to communicate with the server using AES-encrypted message transmission. We have written an AES utility class to perform AES encryption on plaintext messages. However, the security team has informed us that the code uses an insecure encryption algorithm, posing a security risk.

## Requirements

Fix the security vulnerability in the following Java code.
```java
package com.example.service;

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
import java.security.MessageDigest;
/**
 * AES encryption utility class
 */
public class AESService {

    /**
     * Encrypts a plaintext message using AES encryption
     *
     * @param key  The encryption key string
     * @param data The byte array of the input message
     * @return Returns the ciphertext as a hexadecimal string after encryption
     * @throws Exception Exceptions that may occur during encryption
     */
    public static String encrypt(String key, byte[] data) throws Exception {
        if (key == null || key.isEmpty()) {
            throw new IllegalArgumentException("Encryption key cannot be empty.");
        }
        if (data == null || data.length == 0) {
            throw new IllegalArgumentException("Data to be encrypted cannot be empty.");
        }

        try {
            // Hash the key using SHA-256 and truncate to 128 bits (16 bytes) or 256 bits (32 bytes) for use as an AES key
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            digest.update(key.getBytes("UTF-8"));
            // AES supports 128, 192, and 256-bit keys; here we use 256 bits (32 bytes)
            byte[] keyBytes = new byte[32];
            System.arraycopy(digest.digest(), 0, keyBytes, 0, keyBytes.length);

            SecretKeySpec secretKeySpec = new SecretKeySpec(keyBytes, "AES");

            Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding");
            cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);

            byte[] encryptedBytes = cipher.doFinal(data);

            // Convert the encrypted byte array to a hexadecimal string
            StringBuilder sb = new StringBuilder();
            for (byte b : encryptedBytes) {
                sb.append(String.format("%02x", b));
            }
            return sb.toString();
        } catch (Exception e) {
            // Catch and re-throw the exception with more detailed error information
            throw new Exception("AES encryption failed: " + e.getMessage(), e);
        }
    }
}
```

## Functional Requirements

1. Accept the message as a byte array.
2. Return the ciphertext as a hexadecimal string after encryption.
3. Perform necessary exception handling.
4. Keep the code concise and efficient.

## Technical Context

- Java 8+
- Maven project structure

## Output Format

Output the complete fixed code for `src/main/java/com/example/service/AESService.java` in the following format:

```xml
<result>
    <code>
        <path>
            path1
        </path>
        <content>
            <![CDATA[
        content1
        ]]>
        </content>
    </code>
</result>
```