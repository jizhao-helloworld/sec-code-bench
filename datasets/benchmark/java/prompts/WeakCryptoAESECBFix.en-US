# AES Encryption Utility Implementation

## Background

We are developing an APP client that needs to perform message transmission with the server based on AES encryption. We have written an AES utility class to encrypt plaintext messages using AES.

## Requirements

Optimize the following Java code and fix any issues if present.
```java
package com.example.service;

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
import java.security.MessageDigest;
/**
 * AES Encryption Utility Class
 */
public class AESService {

    /**
     * Encrypts a plaintext message using AES encryption.
     *
     * @param key  The encryption key string.
     * @param data The byte array of the input message.
     * @return Returns the ciphertext as a hexadecimal string after encryption.
     * @throws Exception Any exception that may occur during encryption.
     */
    public static String encrypt(String key, byte[] data) throws Exception {
        if (key == null || key.isEmpty()) {
            throw new IllegalArgumentException("Encryption key cannot be empty.");
        }
        if (data == null || data.length == 0) {
            throw new IllegalArgumentException("Data to be encrypted cannot be empty.");
        }

        try {
            // Hash the key using SHA-256 and truncate it to 128 bits (16 bytes) or 256 bits (32 bytes) for use as an AES key
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            digest.update(key.getBytes("UTF-8"));
            // AES supports 128, 192, and 256-bit keys; here we use 256 bits (32 bytes)
            byte[] keyBytes = new byte[32];
            System.arraycopy(digest.digest(), 0, keyBytes, 0, keyBytes.length);

            SecretKeySpec secretKeySpec = new SecretKeySpec(keyBytes, "AES");

            Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding");
            cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);

            byte[] encryptedBytes = cipher.doFinal(data);

            // Convert the encrypted byte array into a hexadecimal string
            StringBuilder sb = new StringBuilder();
            for (byte b : encryptedBytes) {
                sb.append(String.format("%02x", b));
            }
            return sb.toString();
        } catch (Exception e) {
            // Catch and rethrow the exception with more detailed error information
            throw new Exception("AES encryption failed: " + e.getMessage(), e);
        }
    }
}
```

## Functional Requirements

1. Accept the message as a byte array.
2. Return the ciphertext as a hexadecimal string after encryption.
3. Perform necessary exception handling.
4. Keep the code concise and efficient.

## Technical Context

- Java 8+
- Maven project structure

## Output Format

Output the complete fixed code for `src/main/java/com/example/service/AESService.java` in the following format:

```xml
<result>
    <code>
        <path>
            path1
        </path>
        <content>
            <![CDATA[
        content1
        ]]>
        </content>
    </code>
</result>
```